Tips and tricks taken from the official Google guide to interviews. There are a lot of hyperlinks to find out the meaning of the most important terms.


**Coding practice**: You can find sample coding questions on sites like [CodeLab](https://codelabs.developers.google.com/), Quora, and Stack Overflow. The book [Cracking the Coding Interview](http://www.crackingthecodinginterview.com/) is also a good resource. In some sites, you'll have the option to code on either a Chromebook or a whiteboard, to offer a more natural coding environment. (Ask your recruiter what's available so you can practice.) Be sure to test your code and ensure it’s easily readable without bugs. Don’t stress about small syntactical errors like which substring to use for a given method (e.g. start, end or start, length) — just pick one and let your interviewer know.

**Coding**: You should know at least one programming language really well, preferably C++, Java, Python, Go, or C. You will be expected to know APIs, [Object Orientated](https://en.wikipedia.org/wiki/Object-oriented_programming) Design and Programming, how to test your code, as well as come up with [corner cases](https://en.wikipedia.org/wiki/Corner_case) and [edge cases](https://en.wikipedia.org/wiki/Edge_case) for code. Note that we focus on conceptual understanding rather than memorization.

**Algorithms**: Approach the problem with both bottom-up and top-down algorithms. You will be expected to know the *complexity* of an algorithm and how you can improve/change it. Algorithms that are used to solve Google problems include *sorting* (plus searching and *binary search*), [divide-and-conquer](https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm), [dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming)/[memoization](https://en.wikipedia.org/wiki/Memoization), [greediness](https://en.wikipedia.org/wiki/Greedy_algorithm), [recursion](](https://en.wikipedia.org/wiki/Recursion_(computer_science))) or algorithms linked to a specific data structure. Know Big-O notations (e.g. run time) and be ready to discuss complex algorithms like [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) and [A*](https://en.wikipedia.org/wiki/A*_search_algorithm). We recommend discussing or outlining the algorithm you have in mind before writing code.

**Sorting**: Be familiar with common sorting functions and on what kind of input data they’re efficient on or not. Think about efficiency means in terms of runtime and space used. For example, in exceptional cases [insertion-sort](https://en.wikipedia.org/wiki/Insertion_sort) or [radix-sort](https://en.wikipedia.org/wiki/Radix_sort) are much better than the generic QuickSort/MergeSort/HeapSort answers.

**Data Structures**: You should study up on as many data structures as possible. Data structures most frequently used are arrays, linked lists, stacks, queues, hash-sets, [hash-maps, hash-tables](https://en.wikipedia.org/wiki/Hash_table), [dictionary](https://en.wikipedia.org/wiki/Associative_array), trees and binary trees, heaps and graphs. You should know the data structure inside out, and what algorithms tend to go along with each data structure.

**Mathematics**: Some interviewers ask basic discrete math questions. This is more prevalent at Google than at other companies because counting problems, probability problems and other [Discrete Math 101](https://en.wikipedia.org/wiki/Outline_of_discrete_mathematics) situations surround us. Spend some time before the interview refreshing your memory on (or teaching yourself) the essentials of elementary *probability theory* and *combinatorics*. You should be familiar with [n-choose-k](https://en.wikipedia.org/wiki/Binomial_coefficient) problems and their ilk.

**Graphs**: Consider if a problem can be applied with graph algorithms like distance, search, connectivity, [cycle-detection](https://en.wikipedia.org/wiki/Cycle_(graph_theory)#Cycle_detection), etc. There are three basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list) — familiarize yourself with each representation and its pros and cons. You should know the [basic graph traversal algorithms](https://en.wikipedia.org/wiki/Graph_traversal), [breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search) and [depth-first search](https://en.wikipedia.org/wiki/Depth-first_search). Know their computational complexity, their tradeoffs and how to implement them in real code.

**Recursion**: Many coding problems involve thinking recursively and potentially coding a [recursive](https://en.wikipedia.org/wiki/Recursion_(computer_science)) solution. Use recursion to find more elegant solutions to problems that can be solved iteratively.


**Resources:**

- Grow Your Technical Skills with Google [[website]](https://techdevguide.withgoogle.com/#courses)

- Foundations path [[website]](https://techdevguide.withgoogle.com/paths/foundational/)

- Resource Library [[website]](https://techdevguide.withgoogle.com/resources/)



